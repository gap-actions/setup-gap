name: 'Setup GAP for package testing'
description: 'Download and compile GAP and its packages'
inputs:
  gap-version:
    description: 'The GAP version or branch to build'
    required: false
    default: 'latest'
  repository:
    description: 'The GitHub repository from which to clone GAP'
    required: false
    default: 'gap-system/gap'
  configflags:
    description: 'Arguments to pass to the GAP configure script (e.g. --enable-debug)'
    required: false
    default: ''
  gap-pkgs-to-build:
    description: 'A space-separated list of the GAP packages to build'
    required: false
    default: 'io json profiling'
    deprecationMessage: 'This input will possibly be removed in the future, so do not rely on it too much'

runs:
  using: "composite"
  steps:
  
    - name: "Install dependencies"
      shell: bash
      if: ${{ runner.os != 'Windows' }}
      run: |
        if [[ "${{ runner.os }}" == "Linux" ]] ; then
          sudo apt-get install libgmp-dev libreadline-dev zlib1g-dev
        elif [[ "${{ runner.os }}" = "macOS" ]] ; then
          brew install zlib autoconf && brew link zlib --force
        fi

    - name: "Determine GAP version"
      id: version
      shell: bash
      run: |
        VERSION=""
        IS_RELEASE=false

        # Select only those releases we wish to allow, with or without pre-releases

        if [[ -z "${{ inputs.gap-version }}" || "${{ inputs.gap-version }}" == "latest" ]] ; then
          echo "Version: latest release"
          IS_RELEASE=true
          VERSION=$(wget --header="Authorization: Bearer ${{ github.token }}" -qO- "https://api.github.com/repos/${{ inputs.repository }}/releases/latest" | jq -r '.tag_name')
        elif [[ "${{ inputs.gap-version }}" =~ ^(master|main|default)$ ]] ; then
          echo "Version: default branch"
          VERSION=$(git ls-remote --symref https://github.com/${{ inputs.repository }}.git HEAD | head -n 1 | sed 's|ref: refs/heads/||; s|\tHEAD||')
        else
          echo "Checking releases"
          GIT_RELS_JSON=$(wget --header="Authorization: Bearer ${{ github.token }}" -qO- "https://api.github.com/repos/${{ inputs.repository }}/releases")
          GIT_RELS=$(echo "$GIT_RELS_JSON" | jq -r '.[].tag_name' | sort -V)
          GIT_NPRS=$(echo "$GIT_RELS_JSON" | jq -r '.[] | select((.draft == false) and (.prerelease == false)) | .tag_name' | sort -V)

          # Add "v" in front if missing
          REL=${{ inputs.gap-version }}
          REL=v${REL#v}
          
          if echo "$GIT_RELS" | grep -qx "$REL" ; then
            echo "Version: exact release match"
            IS_RELEASE=true
            VERSION=$REL
          elif echo "$GIT_NPRS" | grep -q "^$REL\." ; then
            echo "Version: expanded to release"
            IS_RELEASE=true
            VERSION=$(echo "$GIT_NPRS" | grep "^$REL\." | tail -n 1)
          else
            echo "Checking branches and tags"
            if git ls-remote --heads https://github.com/${{ inputs.repository }}.git | sed 's|.*refs/heads/||' | grep -qx "${{ inputs.gap-version }}" ; then
              echo "Version: exact branch match"
              VERSION=${{ inputs.gap-version }}
            elif git ls-remote --tags --refs https://github.com/${{ inputs.repository }}.git | sed 's|.*refs/tags/||' | grep -qx "${{ inputs.gap-version }}" ; then
              echo "Version: exact tag match"
              VERSION=${{ inputs.gap-version }}
            else
              echo "No release, branch or tag with name ${{ inputs.gap-version }} found"
              exit 1
            fi
          fi
        fi

        echo "VERSION=$VERSION" >> "$GITHUB_OUTPUT"
        echo "IS_RELEASE=$IS_RELEASE" >> "$GITHUB_OUTPUT"

    - name: "Set GAPROOT"
      shell: bash
      run: |
        GAPROOT="$HOME/gap"
        mkdir -p $GAPROOT
        echo "GAPROOT=$GAPROOT" >> "$GITHUB_ENV"
        
    - name: "Download or clone GAP"
      shell: bash
      env:
        VERSION: ${{ steps.version.outputs.VERSION }}
        IS_RELEASE: ${{ steps.version.outputs.IS_RELEASE }}
      run: |
        if [[ "$IS_RELEASE" == "true" ]] ; then
          WGET="wget -q -N --no-check-certificate --tries=5 --waitretry=5 --retry-connrefused"
          URL=https://github.com/${{ inputs.repository }}/releases/download/$VERSION/
          FILE=gap-${VERSION#v}.tar.gz
          $WGET $URL$FILE
          tar xzf $FILE -C $GAPROOT --strip-components=1
        else
          git clone --branch $VERSION --depth=1 --single-branch https://github.com/${{ inputs.repository }}.git $GAPROOT
        fi

    - name: "Build GAP"
      shell: bash
      run: |
        cd $GAPROOT
        CONFIGFLAGS="${{ inputs.configflags }}"
        
        if [ -f "autogen.sh" ] ; then
          echo "::group:: Running autogen"
          ./autogen.sh
        fi

        if [[ "${{ runner.os }}" = "macOS" ]] ; then
          BP=$(brew --prefix)
          CONFIGFLAGS="--with-gmp=$BP --with-readline=$BP/opt/readline $CONFIGFLAGS"
        fi
        echo "::group:: Running configure with flags $CONFIGFLAGS"
        ./configure $CONFIGFLAGS

        echo "::group:: Running make"
        make -j4 V=1

        echo "::group:: Adding GAP to PATH"
        # Add to PATH
        if [ -f "$GAPROOT/gap" ] ; then
          ln -s $GAPROOT/gap /usr/local/bin/gap
        else
          echo -e '#!/bin/sh\nsh '"$GAPROOT"'/bin/gap.sh "$@"\n' > /usr/local/bin/gap
        fi

        # Just to be sure it's executable
        chmod +x /usr/local/bin/gap

    - name: "Download GAP packages"
      shell: bash
      if: ${{ steps.version.outputs.IS_RELEASE == 'false' }}
      run: |
        cd $GAPROOT
        WGET="wget -q -N --no-check-certificate --tries=5 --waitretry=5 --retry-connrefused"
        # For GAP >= 4.11 set DOWNLOAD, for older versions set WGET
        make bootstrap-pkg-full DOWNLOAD="$WGET" WGET="$WGET"

    - name: "Build GAP packages"
      shell: bash
      if: ${{ inputs.gap-pkgs-to-build  != '' }}
      run: |
        BuildPackagesOptions="--strict"
        shopt -s nocaseglob
        cd $GAPROOT/pkg
        for pkg in ${{ inputs.gap-pkgs-to-build }}; do
            ../bin/BuildPackages.sh ${BuildPackagesOptions} $pkg*
        done
